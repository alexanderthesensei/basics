![Pasted image 20241005110902](Pasted%20image%2020241005110902.png)

C - это язык программирования общего назначения, созданный в 1972 году для написания UNIX, предшественника linux.

Сейчас этот язык считается низкоуровневым, потому что он дает вам абсолютный минимум для работы с памятью и процессором, не мешает вам допускать ошибки и не абстрагирует от аппаратной платформы.

---

<div style="page-break-after: always;"></div>

![Pasted image 20241005113652](Pasted%20image%2020241005113652.png)
[Bits & Bytes, ep. 6](https://archive.org/details/bits_and_bytes_6) от TVOntario

## Компилируемые и интерпретируемые языки
Существует два вида языков: компилируемые и интерпретируемые.
При использовании интерпретируемого языка пользователь должен установить на свою машину специальную программу, называемую интерпретатором. Он передает ей исходный код, она читает его построчно и выполняет поступающие инструкции.
В то же время при использовании компилируемого языка вы устанавливаете компилятор на свою машину, передаете ему код, и он переводит вашу программу на машинный язык. Пользователь получает уже скомпилированную программу, не требующую установки компилятора.

---

<div style="page-break-after: always;"></div>

![Pasted image 20241005115104](Pasted%20image%2020241005115104.png)

## Компиляторы C
Для языка C существует несколько компиляторов, самые распространенные из них - GCC и CLang. Для наших целей в принципе неважно, я буду использовать GCC.

---

<div style="page-break-after: always;"></div>

## Использование C

Давайте напишем простую программу, чтобы продемонстрировать, как использовать систему сборки.

---

<div style="page-break-after: always;"></div>

```c
int sum(int x, int y);
```

Начнём с основ. Вот объявление функции. Функция - это именованный, пригодный для многократного использования блок кода, который что-то делает. Имена в этом языке не могут содержать пробелов. Как и в математике, функции могут принимать аргументы ( они находятся между скобками). Аргументы разделяются запятыми. Аргументы - это переменные. Переменная - это именованный фрагмент памяти. И каждый аргумент, и сама функция имеют тип.

---

<div style="page-break-after: always;"></div>

| type           | description               | example |
| -------------- | ------------------------- | ------- |
| `int`          | целые числа               | `-273`  |
| `unsigned int` | натуральные числа         | `42`    |
| `float`        | похоже на научную нотацию | `5.3`   |
| `char`         | единичный символ          | `'c'`   |
| `void`         | пустой тип, нет данных    |         |

Тип - это вид данных, которые туда помещаются. Существует несколько типов для чисел с разной степенью точности, которые используют разный объем памяти (это нужно иметь в виду при работе с очень маленькими встраиваемыми системами, память которых измеряется в кибибайтах), и один символьный тип.

---

<div style="page-break-after: always;"></div>

```c
int sum(int x, int y) {
	// body goes here
}
```

У всех функций есть тело. Тело идет после объявления и завернуто в фигурные скобки.
Вторая строка это комментарий, то есть заметка для других программистов, читающих все это, она игнорируется машиной.

---

<div style="page-break-after: always;"></div>

```c
int add_one(int a) {
	int value = a + 1;
}
```

Обратите внимание, что тип указывается только при объявлении переменной или функции и ставится перед именем. Этот момент очень важен: использование переменной или вызов функции синтаксически отличается от ее *объявления*. В строке 2 мы *объявляем* значение, а используем *а*.

---

<div style="page-break-after: always;"></div>

```c
int add_one(int a) {
	int value = a + 1;
	return value;
}

int x = 8;
int y = add_one(x); // y = 9
```

Функции, не относящиеся к типу `void`, должны что-то `return`ить, а тот, кто их вызвал, получит это значение.
Мы вызываем функцию в строке 9.

Еще точка с запятой служит для обозначения конца команды, поэтому ее нужно ставить после каждой операции. В первой строке точка с запятой не стоит, потому что это *объявление функции*, которое ничего не делает в самой программе - служит только для её организации. Четвертая строка такая же, мы завершаем объявление функции.

---

<div style="page-break-after: always;"></div>

![Pasted image 20241005123733](Pasted%20image%2020241005123733.png)

Обратите внимание, что функция запускается не просто потому, что она там существует, а только после того, как ее вызвали. На рисунке показан порядок выполнения нашего примера. Код выполняется сверху вниз, справа налево.

Операция 1 записывает 8 в новую переменную x.
Операция 2 вызывает функцию, передавая ей значение внутри x, и начинает ждать.
Операция 3 записывает результат прибавления единицы к первому аргументу в новую переменную value.
Операция 4 возвращает значение внутри этой переменной вызывающей функции. Это действие возобновляет выполнение операции 2.
Операция 2 записывает значение, возвращенное вызванной ранее функцией, в новую переменную y.

Y = 9.

---

<div style="page-break-after: always;"></div>

```c
int add_one(int a) {
	return a + 1;
}
```

Вы могли заметить, что мы создаем переменную с именем `value` только для того, чтобы сразу же вернуть ее. Поскольку переменная - это именованный кусок памяти, и нам не нужно имя для нее, мы можем `вернуть` результат операции напрямую. Это еще и более экономично, поскольку мы не выделяем дополнительную память.

---

<div style="page-break-after: always;"></div>

```c
int main() {
	int x = 32;
	int y = 64;
	return x + y;
}
```

С этим покончено, и мы можем написать программу. В языке C программа запускается с функции `main`. Эта функция должна возвращать целое число и может либо не иметь аргументов, либо принимать 2 (подробнее об этом позже).

---

<div style="page-break-after: always;"></div>

```bash
user@machine:~$ gcc program.c # compile it

user@machine:~$ ls
a.out program.c
```

Теперь скомпилируем и запустим ее.

---

<div style="page-break-after: always;"></div>

```bash
user@machine:~$ ./a.out
user@machine:~$
```

Мы говорим машине, чтобы она воспринимала файл с названием `a.out`, расположенный в текущей директории, как команду. Она выполняется молча. Хм.

---

<div style="page-break-after: always;"></div>

```bash
user@machine:~$ echo $?
96
user@machine:~$
```

Любая команда напоминает функцию тем, что принимает аргументы и что-то возвращает. Любая команда возвращает число. Вы можете увидеть это число, попросив оболочку напечатать (или « echo») переменную под названием `?`. Чтобы получить доступ к переменной оболочки, перед ней ставится знак доллара. Bash, zsh, sh и т.д. - это единственные языки, которые это делают.
Обычно программы возвращают 0, если они завершились нормально, или какое-нибудь другое число, если произошла ошибка.

---

<div style="page-break-after: always;"></div>

```c
#include <stdio.h>

int main() {
	int x = 32;
	int y = 64;
	printf("%i", x + y);
}
```

Это хорошо, но большинство команд все же выводят что-то в терминал. Чтобы сделать это, нам нужно обратится к системе. Система предоставляет нам функцию для вывода, но пользоваться ей не так уж удобно. Поэтому в пакете с компилятором есть еще и стандартная библиотека, которая оборачивает этот системный вызов в красивый интерфейс. В первой строке мы просим компилятор предоставить нам данную функцию.

Затем мы запускаем `printf`, функцию «записать это в терминал», и передаем ей 2 аргумента: тип данных и сами данные.

---

<div style="page-break-after: always;"></div>

| c type             | stdio indicator |
| ------------------ | --------------- |
| `int`              | `%i`            |
| `float`            | `%f`            |
| `char`             | `%c`            |
| сырой адрес памяти | `%p`            |

Они немного нестандартны, и представляют собой знак процента и букву.

---

<div style="page-break-after: always;"></div>

```c
#include <stdio.h>

int main() {
	int x = 32;
	int y = 64;
	printf("%i plus %i equals %i", x, y, x + y);
}
```

Это объясняется тем, что вы можете добавить текст до и после данных в том же вызове.

---

<div style="page-break-after: always;"></div>

```c
#include <stdio.h>

void print_sum(int x, int y) {
  int sum = x + y;
  printf("%d plus %d equals %d", x, y, sum);
}

int main() {
  print_sum(32, 64);
  print_sum(128, 256);
  return 0;
}
```

И наконец, мы можем перенести это утверждение в функцию, если это необходимо.

---

<div style="page-break-after: always;"></div>

## Подведение итогов

- компилятор и интерпретатор
- функции
- функция `main`
- переменные
- типы данных
- коды возврата команд

На этом мы пока остановимся, в следующий раз мы будем работать с пользователем и решать, что делать, основываясь на введенных данных.