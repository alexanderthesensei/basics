## Control flow
notes:
Программы почти никогда не работают линейно - в зависимости от входных данных им приходится на ходу менять свое поведение. Для этого в языке Си есть 3 основных оператора ~~а также `do while` и `goto`, про которые лучше не знать~~.

---

```c
if (...) {
	...
}
```
notes:
Тело оператора if выполняется только в том случае, если выражение, переданное ifу, не равно нулю.

---

```c
if (1) {
	printf("Это запускается всегда\n");
}
```
```bash
user@machine:~/flow$ gcc control_flow.c
user@machine:~/flow$ ./a.out
Это запускается всегда
user@machine:~/flow$
```
notes:
Число - это выражение

---

```c
if (2 > 3) {
	printf("Это не запускается никогда\n");
}
```
```bash
user@machine:~/flow$ gcc control_flow.c
user@machine:~/flow$ ./a.out
user@machine:~/flow$
```
notes: Сравнение - это выражение

---

```c
int yes() {
	return 1;
}

if (yes()) {
	printf("Это запускается всегда\n");
}
```
```bash
user@machine:~/flow$ gcc control_flow.c
user@machine:~/flow$ ./a.out
Это запускается всегда
```
(В следующих примерах я буду показывать результат выполнения программы без команды сборки)

notes: И переменная или возвращаемое значение функции - это тоже выражение.

---

- `>`
- `<`
- `<=`
- `>=`
- `==`
- `!=` (не равно)

notes:
Давайте рассмотрим несколько распространенных способов работы с выражениями. Вот операторы сравнения. Они берут два выражения и возвращают 1 или 0 (что означает истина или ложь соответственно).

---

```c
int x = 0;

if (x = 2) {
	printf("Проблема 1. Этот код запускается.\n");
}

printf("Проблема 2. Теперь x = %d.\n", x);
```
```text
Проблема 1. Этот код запускается.
Проблема 2. Теперь x = 2.
```
notes:
Обратите внимание, что при проверке равенства используются 2 знака равно, а не один. Это объясняется тем, что один знак равно - это оператор присваивания, который мы использовали ранее для задания переменным их значений. *Компилятор не станет вас предупреждать*, если вы используете неправильный оператор.

---

```c
int x = 0;

if (2 = x) {
	printf("Проблема 1. Этот код запускается.\n");
}

printf("Проблема 2. Теперь x = %d.\n", x);
```
```text
flow.c: In function ‘main’:
flow.c:6:9: error: lvalue required as left operand of assignment
    6 |   if (2 = x) {
      |         ^
```
notes:
Если вы хотите, чтобы он это делал, вы можете использовать нотацию Йоды.

---

```c
int x = 0;

if (2 == x) {
	printf("Это больше не печатается.\n");
}

printf("И x по-прежнему равен %d!\n", x);
```
```text
И x по-прежнему равен 0!
```
notes:
Вот исправленный вариант.

---

- `&&` и
- `||` или
- `!` не

notes:
Существуют также логические операторы. Оператор и берет два целых числа и возвращает единицу, если они оба равны единице. Или принимает два целых числа и возвращает ноль, если они оба равны нулю. Не берет выражение и инвертирует его.

---

```c
int x = 32;

if (16 < x && x < 64) {
	printf("X ∈ (16; 64)\n");
}
```
```text
X ∈ (16; 64)
```
notes:
Вот пример, использующий сочетание вышеперечисленных операторов.

---

```c
int x = 8;

if (16 < x && x < 64) {
	printf("X ∈ (16; 64)\n");
} else {
	printf("X ∉ (16; 64)\n");
}
```
```text
X ∉ (16; 64)
```

notes:
Любой if может иметь блок `else`, который будет выполняться, если выражение равно нулю.

---

```c
void check_range(int x) {
    if (16 < x && x < 64) {
        printf("X ∈ (16; 64)\n");
    } else {
        if (x <= 16) {
            printf("X ∈ (-∞; 16]\n");
        } else {
            printf("X ∈ [64; +∞)\n");
        }
    }
}
```
```c
int main() {
    check_range(-32);
    check_range(+32);
    check_range(+64);
}
```
```text
X ∈ (-∞; 16]
X ∈ (16; 64)
X ∈ [64; +∞)
```
notes:
Вы можете поместить блок if внутри другого блока if, но это добавит много лишних букв и ухудшит читаемость.

---

```c
void check_range(int x) {
    if (16 < x && x < 64) {
        printf("X ∈ (16; 64)\n");
    } else if (x <= 16) {
        printf("X ∈ (-∞; 16]\n");
    } else {
        printf("X ∈ [64; +∞)\n");
    }
}
```
```c
int main() {
    check_range(-32);
    check_range(+32);
    check_range(+64);
}
```
```text
X ∈ (-∞; 16]
X ∈ (16; 64)
X ∈ [64; +∞)
```
notes:
Вы можете использовать блоки `else if`, чтобы сжимать выражения, подобные последнему.

---

```c
void sequence(int min, int max) {
    if (0 == min) {
        printf("{"); // первый элемент
    }
    
    printf("%d", min);
    if (max == min) {
        printf("}\n"); // последний элемент
        return;
    } else {
        printf(", "); // продолжаем последовательность
        sequence(min + 1, max); // рекурсия
    }
}
```
```c
int main() {
    sequence(0, 8);
}
```
```text
{0, 1, 2, 3, 4, 5, 6, 7, 8}
```

notes:
Используя только if и функции, вы можете создавать циклы. Для этого нужно заставить функцию вызывать саму себя по какому-то условию. Такая конструкция называется рекурсией.

---

```c
int index = 0;
int max = 8;
printf("{");

while (index < max) {
	printf("%d, ", index);
	index++; // то же, что `index = index + 1;`
}

printf("%d}\n", max);
```
```text
{0, 1, 2, 3, 4, 5, 6, 7, 8}
```
notes:
В Си есть специальный синтаксис для циклов, чтобы не создавать функцию каждый раз, когда вы хотите что-то повторить. Цикл `while` похож на оператор if, за исключением того, что его тело выполняется постоянно, пока условие не равно нулю, а не только один раз. Такой подход зачастую проще.

---

```c
int max = 8;
printf("{");

for (int i = 0; i < max; i++) {
    printf("%d, ", i);
}

printf("%d}\n", max);
```
```text
{0, 1, 2, 3, 4, 5, 6, 7, 8}
```
notes:
Цикл for - это просто сокращение цикла while с вписанным в него счетчиком. У него есть 3 аргумента - переменная-счетчик, условие выполнения и действие, выполняемое после каждой итерации. Переменная счетчика часто объявляется на месте и называется i (сокращение от index).

---

```c
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 4; j++) {
        printf("%d ", i * j);
    }
    printf("\n");
}
```
```text
0 0 0 0
0 1 2 3
0 2 4 6
```
notes:
Циклы могут быть вложенными. Вот, например, таблица умножения.

---

## Домашка
- [fizzbuzz](https://ru.wikipedia.org/wiki/Fizz_buzz)
- вывести [последовательность Фибоначчи](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8)
- построить таблицу умножения 10х10

notes:
Автор: [alexanderthestudent](https://github.com/alexanderthesensei), 2024-11-02.

Соавтор: [DeepL Translate](https://deepl.com).